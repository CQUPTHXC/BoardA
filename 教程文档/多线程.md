<!--
 * @LastEditors: qingmeijiupiao
 * @Description: 
 * @Author: qingmeijiupiao
 * @Date: 2024-08-02 23:20:41
-->
# 基于Esp32的多线程
Esp32多线程的实现基于freertos，但是对c++的标准库进行了重写 
例如：std::thread、std::mutex、std::condition_variable
详情：https://docs.espressif.com/projects/esp-idf/zh_CN/latest/esp32/api-reference/system/pthread.html#posix-thread-api

尽管依然可以使用标准freertos函数构建线程，但是强烈推荐使用c++标准库，因为它具有更好的安全性和开发效率
## 使用c++标准库进行多线程的构建
### 1. std::thread
#### 1.1 创建线程
```cpp
#include <thread>
#include <esp_pthread.h>
void function(){
    //do something
}
void function2(){
    while(1){
        //do something

        
        std::this_thread::sleep_for(std::chrono::seconds(1));//等待1秒
        //如果想使用ms
        std::this_thread::sleep_for(std::chrono::milliseconds(100));//等待100ms
        
        //推荐使用delay(),可以实现sleep的效果这里是程
        delay(1000);//等待1秒
        //delay是被重写过的不会阻塞其他任务
    }
    
}
void function3(int a,float b){
    //do something
}
void setup(){
    std::thread task(function);//创建使用默认参数的线程

    //或者可以指定参数
    auto cfg = esp_pthread_get_default_config();//cfg为线程配置结构体
    cfg.thread_name = "task2";//设置线程名
    cfg.pin_to_core = 0;//设置线程在哪个核上执行
    cfg.stack_size = 1024*4;//栈大小
    cfg.prio = 5;//优先级
    esp_pthread_set_cfg(&cfg);//设置线程配置
    std::thread task2(function2);//创建使用指定参数的线程

    std::thread task3(function3,1,0.5);//创建线程时传入参数

}
```
### 2. 线程锁
当多线程需要互斥访问同一资源时，有时候会出现线程安全问题，可以使用线程锁
典型的应用场景：多个线程同时访问一个串口

```cpp

#include <mutex>

std::mutex serial_mutex;

void function1(){
    while(1){
        serial_mutex.lock();
        Serial.println("function1");

        //wait to read
        while(!Serial.available()){delay(1);}
        Serial.read();
        serial_mutex.unlock();
    }
}
void function2(){
    while(1){
        serial_mutex.lock();
        Serial.println("function2");
        //wait to read
        while(!Serial.available()){delay(1);}
        Serial.read();

        serial_mutex.unlock();
    }
}
//可以使用std::lock_guard自动上锁
void mitex_test(){
    std::lock_guard<std::mutex> guard(serial_mutex);//上锁
    //do something
    return;
    //std::lock_guard 是一个作用域锁定器，它在构造时自动锁定互斥锁，并在析构时自动释放锁。这样可以避免忘记解锁互斥锁，并且可以处理异常安全地释放锁：
}
void setup(){
    Serial.begin(115200);
    std::thread task1(function1);//创建使用默认参数的线程
    std::thread task2(function2);//创建使用默认参数的线程
}

    
```
